/**
 * This code was AUTOGENERATED using the codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
  combineCodec,
  fixDecoderSize,
  fixEncoderSize,
  getBytesDecoder,
  getBytesEncoder,
  getStructDecoder,
  getStructEncoder,
  transformEncoder,
  type Address,
  type Codec,
  type Decoder,
  type Encoder,
  type IAccountMeta,
  type IAccountSignerMeta,
  type IInstruction,
  type IInstructionWithAccounts,
  type IInstructionWithData,
  type OptionOrNullable,
  type ReadonlyAccount,
  type ReadonlySignerAccount,
  type ReadonlyUint8Array,
  type TransactionSigner,
  type WritableAccount,
  type WritableSignerAccount,
} from '@solana/kit';
import {
  resolveAuthorityPda,
  resolveEventAuthorityPda,
  resolveProgram,
} from '../../hooked';
import { findUnclaimedPrizesPda } from '../pdas';
import { MALLOW_JELLYBEAN_PROGRAM_ADDRESS } from '../programs';
import {
  expectAddress,
  getAccountMetaFactory,
  type ResolvedAccount,
} from '../shared';

export const DRAW_DISCRIMINATOR = new Uint8Array([
  61, 40, 62, 184, 31, 176, 24, 130,
]);

export function getDrawDiscriminatorBytes() {
  return fixEncoderSize(getBytesEncoder(), 8).encode(DRAW_DISCRIMINATOR);
}

export type DrawInstruction<
  TProgram extends string = typeof MALLOW_JELLYBEAN_PROGRAM_ADDRESS,
  TAccountJellybeanMachine extends string | IAccountMeta<string> = string,
  TAccountAuthorityPda extends string | IAccountMeta<string> = string,
  TAccountMintAuthority extends string | IAccountMeta<string> = string,
  TAccountPayer extends string | IAccountMeta<string> = string,
  TAccountBuyer extends string | IAccountMeta<string> = string,
  TAccountUnclaimedPrizes extends string | IAccountMeta<string> = string,
  TAccountSystemProgram extends
    | string
    | IAccountMeta<string> = '11111111111111111111111111111111',
  TAccountRent extends
    | string
    | IAccountMeta<string> = 'SysvarRent111111111111111111111111111111111',
  TAccountRecentSlothashes extends
    | string
    | IAccountMeta<string> = 'SysvarS1otHashes111111111111111111111111111',
  TAccountEventAuthority extends string | IAccountMeta<string> = string,
  TAccountProgram extends string | IAccountMeta<string> = string,
  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],
> = IInstruction<TProgram> &
  IInstructionWithData<Uint8Array> &
  IInstructionWithAccounts<
    [
      TAccountJellybeanMachine extends string
        ? WritableAccount<TAccountJellybeanMachine>
        : TAccountJellybeanMachine,
      TAccountAuthorityPda extends string
        ? WritableAccount<TAccountAuthorityPda>
        : TAccountAuthorityPda,
      TAccountMintAuthority extends string
        ? ReadonlySignerAccount<TAccountMintAuthority> &
            IAccountSignerMeta<TAccountMintAuthority>
        : TAccountMintAuthority,
      TAccountPayer extends string
        ? WritableSignerAccount<TAccountPayer> &
            IAccountSignerMeta<TAccountPayer>
        : TAccountPayer,
      TAccountBuyer extends string
        ? ReadonlyAccount<TAccountBuyer>
        : TAccountBuyer,
      TAccountUnclaimedPrizes extends string
        ? WritableAccount<TAccountUnclaimedPrizes>
        : TAccountUnclaimedPrizes,
      TAccountSystemProgram extends string
        ? ReadonlyAccount<TAccountSystemProgram>
        : TAccountSystemProgram,
      TAccountRent extends string
        ? ReadonlyAccount<TAccountRent>
        : TAccountRent,
      TAccountRecentSlothashes extends string
        ? ReadonlyAccount<TAccountRecentSlothashes>
        : TAccountRecentSlothashes,
      TAccountEventAuthority extends string
        ? ReadonlyAccount<TAccountEventAuthority>
        : TAccountEventAuthority,
      TAccountProgram extends string
        ? ReadonlyAccount<TAccountProgram>
        : TAccountProgram,
      ...TRemainingAccounts,
    ]
  >;

export type DrawInstructionData = { discriminator: ReadonlyUint8Array };

export type DrawInstructionDataArgs = {};

export function getDrawInstructionDataEncoder(): Encoder<DrawInstructionDataArgs> {
  return transformEncoder(
    getStructEncoder([['discriminator', fixEncoderSize(getBytesEncoder(), 8)]]),
    (value) => ({ ...value, discriminator: DRAW_DISCRIMINATOR })
  );
}

export function getDrawInstructionDataDecoder(): Decoder<DrawInstructionData> {
  return getStructDecoder([
    ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
  ]);
}

export function getDrawInstructionDataCodec(): Codec<
  DrawInstructionDataArgs,
  DrawInstructionData
> {
  return combineCodec(
    getDrawInstructionDataEncoder(),
    getDrawInstructionDataDecoder()
  );
}

export type DrawInstructionExtraArgs = {
  /** Forcing DrawInstructionExtraArgs to be rendered to fix a bug where resolvedArgs is using an undefined type */
  unused?: OptionOrNullable<boolean>;
};

export type DrawAsyncInput<
  TAccountJellybeanMachine extends string = string,
  TAccountAuthorityPda extends string = string,
  TAccountMintAuthority extends string = string,
  TAccountPayer extends string = string,
  TAccountBuyer extends string = string,
  TAccountUnclaimedPrizes extends string = string,
  TAccountSystemProgram extends string = string,
  TAccountRent extends string = string,
  TAccountRecentSlothashes extends string = string,
  TAccountEventAuthority extends string = string,
  TAccountProgram extends string = string,
> = {
  /** Jellybean machine account. */
  jellybeanMachine: Address<TAccountJellybeanMachine>;
  authorityPda?: Address<TAccountAuthorityPda>;
  /** Jellybean machine mint authority (mint only allowed for the mint_authority). */
  mintAuthority: TransactionSigner<TAccountMintAuthority>;
  /** Payer for the transaction and account allocation (rent). */
  payer: TransactionSigner<TAccountPayer>;
  /**
   * NFT account owner.
   *
   */
  buyer: Address<TAccountBuyer>;
  /** Buyer unclaimed draws account. */
  unclaimedPrizes?: Address<TAccountUnclaimedPrizes>;
  /** System program. */
  systemProgram?: Address<TAccountSystemProgram>;
  /** Rent. */
  rent?: Address<TAccountRent>;
  /**
   * SlotHashes sysvar cluster data.
   *
   */
  recentSlothashes?: Address<TAccountRecentSlothashes>;
  eventAuthority?: Address<TAccountEventAuthority>;
  program?: Address<TAccountProgram>;
  unused?: DrawInstructionExtraArgs['unused'];
};

export async function getDrawInstructionAsync<
  TAccountJellybeanMachine extends string,
  TAccountAuthorityPda extends string,
  TAccountMintAuthority extends string,
  TAccountPayer extends string,
  TAccountBuyer extends string,
  TAccountUnclaimedPrizes extends string,
  TAccountSystemProgram extends string,
  TAccountRent extends string,
  TAccountRecentSlothashes extends string,
  TAccountEventAuthority extends string,
  TAccountProgram extends string,
  TProgramAddress extends Address = typeof MALLOW_JELLYBEAN_PROGRAM_ADDRESS,
>(
  input: DrawAsyncInput<
    TAccountJellybeanMachine,
    TAccountAuthorityPda,
    TAccountMintAuthority,
    TAccountPayer,
    TAccountBuyer,
    TAccountUnclaimedPrizes,
    TAccountSystemProgram,
    TAccountRent,
    TAccountRecentSlothashes,
    TAccountEventAuthority,
    TAccountProgram
  >,
  config?: { programAddress?: TProgramAddress }
): Promise<
  DrawInstruction<
    TProgramAddress,
    TAccountJellybeanMachine,
    TAccountAuthorityPda,
    TAccountMintAuthority,
    TAccountPayer,
    TAccountBuyer,
    TAccountUnclaimedPrizes,
    TAccountSystemProgram,
    TAccountRent,
    TAccountRecentSlothashes,
    TAccountEventAuthority,
    TAccountProgram
  >
> {
  // Program address.
  const programAddress =
    config?.programAddress ?? MALLOW_JELLYBEAN_PROGRAM_ADDRESS;

  // Original accounts.
  const originalAccounts = {
    jellybeanMachine: {
      value: input.jellybeanMachine ?? null,
      isWritable: true,
    },
    authorityPda: { value: input.authorityPda ?? null, isWritable: true },
    mintAuthority: { value: input.mintAuthority ?? null, isWritable: false },
    payer: { value: input.payer ?? null, isWritable: true },
    buyer: { value: input.buyer ?? null, isWritable: false },
    unclaimedPrizes: { value: input.unclaimedPrizes ?? null, isWritable: true },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false },
    rent: { value: input.rent ?? null, isWritable: false },
    recentSlothashes: {
      value: input.recentSlothashes ?? null,
      isWritable: false,
    },
    eventAuthority: { value: input.eventAuthority ?? null, isWritable: false },
    program: { value: input.program ?? null, isWritable: false },
  };
  const accounts = originalAccounts as Record<
    keyof typeof originalAccounts,
    ResolvedAccount
  >;

  // Original args.
  const args = { ...input };

  // Resolver scope.
  const resolverScope = { programAddress, accounts, args };

  // Resolve default values.
  if (!accounts.authorityPda.value) {
    accounts.authorityPda = {
      ...accounts.authorityPda,
      ...resolveAuthorityPda(resolverScope),
    };
  }
  if (!accounts.unclaimedPrizes.value) {
    accounts.unclaimedPrizes.value = await findUnclaimedPrizesPda({
      jellybeanMachine: expectAddress(accounts.jellybeanMachine.value),
      buyer: expectAddress(accounts.buyer.value),
    });
  }
  if (!accounts.systemProgram.value) {
    accounts.systemProgram.value =
      '11111111111111111111111111111111' as Address<'11111111111111111111111111111111'>;
  }
  if (!accounts.rent.value) {
    accounts.rent.value =
      'SysvarRent111111111111111111111111111111111' as Address<'SysvarRent111111111111111111111111111111111'>;
  }
  if (!accounts.recentSlothashes.value) {
    accounts.recentSlothashes.value =
      'SysvarS1otHashes111111111111111111111111111' as Address<'SysvarS1otHashes111111111111111111111111111'>;
  }
  if (!accounts.eventAuthority.value) {
    accounts.eventAuthority = {
      ...accounts.eventAuthority,
      ...resolveEventAuthorityPda(resolverScope),
    };
  }
  if (!accounts.program.value) {
    accounts.program = {
      ...accounts.program,
      ...resolveProgram(resolverScope),
    };
  }
  if (!args.unused) {
    args.unused = false;
  }

  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
  const instruction = {
    accounts: [
      getAccountMeta(accounts.jellybeanMachine),
      getAccountMeta(accounts.authorityPda),
      getAccountMeta(accounts.mintAuthority),
      getAccountMeta(accounts.payer),
      getAccountMeta(accounts.buyer),
      getAccountMeta(accounts.unclaimedPrizes),
      getAccountMeta(accounts.systemProgram),
      getAccountMeta(accounts.rent),
      getAccountMeta(accounts.recentSlothashes),
      getAccountMeta(accounts.eventAuthority),
      getAccountMeta(accounts.program),
    ],
    programAddress,
    data: getDrawInstructionDataEncoder().encode({}),
  } as DrawInstruction<
    TProgramAddress,
    TAccountJellybeanMachine,
    TAccountAuthorityPda,
    TAccountMintAuthority,
    TAccountPayer,
    TAccountBuyer,
    TAccountUnclaimedPrizes,
    TAccountSystemProgram,
    TAccountRent,
    TAccountRecentSlothashes,
    TAccountEventAuthority,
    TAccountProgram
  >;

  return instruction;
}

export type DrawInput<
  TAccountJellybeanMachine extends string = string,
  TAccountAuthorityPda extends string = string,
  TAccountMintAuthority extends string = string,
  TAccountPayer extends string = string,
  TAccountBuyer extends string = string,
  TAccountUnclaimedPrizes extends string = string,
  TAccountSystemProgram extends string = string,
  TAccountRent extends string = string,
  TAccountRecentSlothashes extends string = string,
  TAccountEventAuthority extends string = string,
  TAccountProgram extends string = string,
> = {
  /** Jellybean machine account. */
  jellybeanMachine: Address<TAccountJellybeanMachine>;
  authorityPda?: Address<TAccountAuthorityPda>;
  /** Jellybean machine mint authority (mint only allowed for the mint_authority). */
  mintAuthority: TransactionSigner<TAccountMintAuthority>;
  /** Payer for the transaction and account allocation (rent). */
  payer: TransactionSigner<TAccountPayer>;
  /**
   * NFT account owner.
   *
   */
  buyer: Address<TAccountBuyer>;
  /** Buyer unclaimed draws account. */
  unclaimedPrizes: Address<TAccountUnclaimedPrizes>;
  /** System program. */
  systemProgram?: Address<TAccountSystemProgram>;
  /** Rent. */
  rent?: Address<TAccountRent>;
  /**
   * SlotHashes sysvar cluster data.
   *
   */
  recentSlothashes?: Address<TAccountRecentSlothashes>;
  eventAuthority?: Address<TAccountEventAuthority>;
  program?: Address<TAccountProgram>;
  unused?: DrawInstructionExtraArgs['unused'];
};

export function getDrawInstruction<
  TAccountJellybeanMachine extends string,
  TAccountAuthorityPda extends string,
  TAccountMintAuthority extends string,
  TAccountPayer extends string,
  TAccountBuyer extends string,
  TAccountUnclaimedPrizes extends string,
  TAccountSystemProgram extends string,
  TAccountRent extends string,
  TAccountRecentSlothashes extends string,
  TAccountEventAuthority extends string,
  TAccountProgram extends string,
  TProgramAddress extends Address = typeof MALLOW_JELLYBEAN_PROGRAM_ADDRESS,
>(
  input: DrawInput<
    TAccountJellybeanMachine,
    TAccountAuthorityPda,
    TAccountMintAuthority,
    TAccountPayer,
    TAccountBuyer,
    TAccountUnclaimedPrizes,
    TAccountSystemProgram,
    TAccountRent,
    TAccountRecentSlothashes,
    TAccountEventAuthority,
    TAccountProgram
  >,
  config?: { programAddress?: TProgramAddress }
): DrawInstruction<
  TProgramAddress,
  TAccountJellybeanMachine,
  TAccountAuthorityPda,
  TAccountMintAuthority,
  TAccountPayer,
  TAccountBuyer,
  TAccountUnclaimedPrizes,
  TAccountSystemProgram,
  TAccountRent,
  TAccountRecentSlothashes,
  TAccountEventAuthority,
  TAccountProgram
> {
  // Program address.
  const programAddress =
    config?.programAddress ?? MALLOW_JELLYBEAN_PROGRAM_ADDRESS;

  // Original accounts.
  const originalAccounts = {
    jellybeanMachine: {
      value: input.jellybeanMachine ?? null,
      isWritable: true,
    },
    authorityPda: { value: input.authorityPda ?? null, isWritable: true },
    mintAuthority: { value: input.mintAuthority ?? null, isWritable: false },
    payer: { value: input.payer ?? null, isWritable: true },
    buyer: { value: input.buyer ?? null, isWritable: false },
    unclaimedPrizes: { value: input.unclaimedPrizes ?? null, isWritable: true },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false },
    rent: { value: input.rent ?? null, isWritable: false },
    recentSlothashes: {
      value: input.recentSlothashes ?? null,
      isWritable: false,
    },
    eventAuthority: { value: input.eventAuthority ?? null, isWritable: false },
    program: { value: input.program ?? null, isWritable: false },
  };
  const accounts = originalAccounts as Record<
    keyof typeof originalAccounts,
    ResolvedAccount
  >;

  // Original args.
  const args = { ...input };

  // Resolver scope.
  const resolverScope = { programAddress, accounts, args };

  // Resolve default values.
  if (!accounts.authorityPda.value) {
    accounts.authorityPda = {
      ...accounts.authorityPda,
      ...resolveAuthorityPda(resolverScope),
    };
  }
  if (!accounts.systemProgram.value) {
    accounts.systemProgram.value =
      '11111111111111111111111111111111' as Address<'11111111111111111111111111111111'>;
  }
  if (!accounts.rent.value) {
    accounts.rent.value =
      'SysvarRent111111111111111111111111111111111' as Address<'SysvarRent111111111111111111111111111111111'>;
  }
  if (!accounts.recentSlothashes.value) {
    accounts.recentSlothashes.value =
      'SysvarS1otHashes111111111111111111111111111' as Address<'SysvarS1otHashes111111111111111111111111111'>;
  }
  if (!accounts.eventAuthority.value) {
    accounts.eventAuthority = {
      ...accounts.eventAuthority,
      ...resolveEventAuthorityPda(resolverScope),
    };
  }
  if (!accounts.program.value) {
    accounts.program = {
      ...accounts.program,
      ...resolveProgram(resolverScope),
    };
  }
  if (!args.unused) {
    args.unused = false;
  }

  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
  const instruction = {
    accounts: [
      getAccountMeta(accounts.jellybeanMachine),
      getAccountMeta(accounts.authorityPda),
      getAccountMeta(accounts.mintAuthority),
      getAccountMeta(accounts.payer),
      getAccountMeta(accounts.buyer),
      getAccountMeta(accounts.unclaimedPrizes),
      getAccountMeta(accounts.systemProgram),
      getAccountMeta(accounts.rent),
      getAccountMeta(accounts.recentSlothashes),
      getAccountMeta(accounts.eventAuthority),
      getAccountMeta(accounts.program),
    ],
    programAddress,
    data: getDrawInstructionDataEncoder().encode({}),
  } as DrawInstruction<
    TProgramAddress,
    TAccountJellybeanMachine,
    TAccountAuthorityPda,
    TAccountMintAuthority,
    TAccountPayer,
    TAccountBuyer,
    TAccountUnclaimedPrizes,
    TAccountSystemProgram,
    TAccountRent,
    TAccountRecentSlothashes,
    TAccountEventAuthority,
    TAccountProgram
  >;

  return instruction;
}

export type ParsedDrawInstruction<
  TProgram extends string = typeof MALLOW_JELLYBEAN_PROGRAM_ADDRESS,
  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],
> = {
  programAddress: Address<TProgram>;
  accounts: {
    /** Jellybean machine account. */
    jellybeanMachine: TAccountMetas[0];
    authorityPda: TAccountMetas[1];
    /** Jellybean machine mint authority (mint only allowed for the mint_authority). */
    mintAuthority: TAccountMetas[2];
    /** Payer for the transaction and account allocation (rent). */
    payer: TAccountMetas[3];
    /**
     * NFT account owner.
     *
     */

    buyer: TAccountMetas[4];
    /** Buyer unclaimed draws account. */
    unclaimedPrizes: TAccountMetas[5];
    /** System program. */
    systemProgram: TAccountMetas[6];
    /** Rent. */
    rent: TAccountMetas[7];
    /**
     * SlotHashes sysvar cluster data.
     *
     */

    recentSlothashes: TAccountMetas[8];
    eventAuthority: TAccountMetas[9];
    program: TAccountMetas[10];
  };
  data: DrawInstructionData;
};

export function parseDrawInstruction<
  TProgram extends string,
  TAccountMetas extends readonly IAccountMeta[],
>(
  instruction: IInstruction<TProgram> &
    IInstructionWithAccounts<TAccountMetas> &
    IInstructionWithData<Uint8Array>
): ParsedDrawInstruction<TProgram, TAccountMetas> {
  if (instruction.accounts.length < 11) {
    // TODO: Coded error.
    throw new Error('Not enough accounts');
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts![accountIndex]!;
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      jellybeanMachine: getNextAccount(),
      authorityPda: getNextAccount(),
      mintAuthority: getNextAccount(),
      payer: getNextAccount(),
      buyer: getNextAccount(),
      unclaimedPrizes: getNextAccount(),
      systemProgram: getNextAccount(),
      rent: getNextAccount(),
      recentSlothashes: getNextAccount(),
      eventAuthority: getNextAccount(),
      program: getNextAccount(),
    },
    data: getDrawInstructionDataDecoder().decode(instruction.data),
  };
}
